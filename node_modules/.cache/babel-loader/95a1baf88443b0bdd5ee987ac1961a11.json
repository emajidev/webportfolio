{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/majidev/Documentos/dev/portfolio/portfolio-emajidev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/majidev/Documentos/dev/portfolio/portfolio-emajidev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/majidev/Documentos/dev/portfolio/portfolio-emajidev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/majidev/Documentos/dev/portfolio/portfolio-emajidev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nvar Utils_1 = require(\"../../Utils\");\n\nvar Enums_1 = require(\"../../Enums\");\n\nvar Updater = /*#__PURE__*/function () {\n  function Updater(container, particle) {\n    _classCallCheck(this, Updater);\n\n    this.container = container;\n    this.particle = particle;\n  }\n\n  _createClass(Updater, [{\n    key: \"update\",\n    value: function update(delta) {\n      if (this.particle.destroyed) {\n        return;\n      }\n\n      this.updateOpacity(delta);\n      this.updateSize(delta);\n      this.updateAngle(delta);\n      this.updateColor(delta);\n      this.updateStrokeColor(delta);\n      this.updateOutMode(delta);\n    }\n  }, {\n    key: \"updateOpacity\",\n    value: function updateOpacity(delta) {\n      var particle = this.particle;\n\n      if (particle.particlesOptions.opacity.animation.enable) {\n        switch (particle.opacity.status) {\n          case Enums_1.OpacityAnimationStatus.increasing:\n            if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n              particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n            } else {\n              particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n            }\n\n            break;\n\n          case Enums_1.OpacityAnimationStatus.decreasing:\n            if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n              particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n            } else {\n              particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n            }\n\n            break;\n        }\n\n        if (particle.opacity.value < 0) {\n          particle.opacity.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(delta) {\n      var _a;\n\n      var container = this.container;\n      var particle = this.particle;\n      var sizeOpt = particle.particlesOptions.size;\n      var sizeAnim = sizeOpt.animation;\n\n      if (sizeAnim.enable) {\n        switch (particle.size.status) {\n          case Enums_1.SizeAnimationStatus.increasing:\n            if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n              particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n            } else {\n              particle.size.value += (particle.size.velocity || 0) * delta.factor;\n            }\n\n            break;\n\n          case Enums_1.SizeAnimationStatus.decreasing:\n            if (particle.size.value <= sizeAnim.minimumValue) {\n              particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n            } else {\n              particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n            }\n\n        }\n\n        switch (sizeAnim.destroy) {\n          case Enums_1.DestroyType.max:\n            if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n              particle.destroy();\n            }\n\n            break;\n\n          case Enums_1.DestroyType.min:\n            if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n              particle.destroy();\n            }\n\n            break;\n        }\n\n        if (particle.size.value < 0 && !particle.destroyed) {\n          particle.size.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateAngle\",\n    value: function updateAngle(delta) {\n      var particle = this.particle;\n      var rotate = particle.particlesOptions.rotate;\n      var rotateAnimation = rotate.animation;\n      var speed = rotateAnimation.speed / 360 * delta.factor;\n      var max = 2 * Math.PI;\n\n      if (rotate.path) {\n        particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n      } else {\n        if (rotateAnimation.enable) {\n          switch (particle.rotateDirection) {\n            case Enums_1.RotateDirection.clockwise:\n              particle.angle += speed;\n\n              if (particle.angle > max) {\n                particle.angle -= max;\n              }\n\n              break;\n\n            case Enums_1.RotateDirection.counterClockwise:\n            default:\n              particle.angle -= speed;\n\n              if (particle.angle < 0) {\n                particle.angle += max;\n              }\n\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateColor\",\n    value: function updateColor(delta) {\n      var particle = this.particle;\n\n      if (particle.color === undefined) {\n        return;\n      }\n\n      if (particle.particlesOptions.color.animation.enable) {\n        particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n\n        if (particle.color.h > 360) {\n          particle.color.h -= 360;\n        }\n      }\n    }\n  }, {\n    key: \"updateStrokeColor\",\n    value: function updateStrokeColor(delta) {\n      var particle = this.particle;\n      var color = particle.stroke.color;\n\n      if (typeof color === \"string\" || color === undefined) {\n        return;\n      }\n\n      if (particle.strokeColor === undefined) {\n        return;\n      }\n\n      if (color.animation.enable) {\n        particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n\n        if (particle.strokeColor.h > 360) {\n          particle.strokeColor.h -= 360;\n        }\n      }\n    }\n  }, {\n    key: \"fixOutOfCanvasPosition\",\n    value: function fixOutOfCanvasPosition() {\n      var container = this.container;\n      var particle = this.particle;\n      var wrap = particle.particlesOptions.move.warp;\n      var canvasSize = container.canvas.size;\n      var newPos = {\n        bottom: canvasSize.height + particle.size.value - particle.offset.y,\n        left: -particle.size.value - particle.offset.x,\n        right: canvasSize.width + particle.size.value + particle.offset.x,\n        top: -particle.size.value - particle.offset.y\n      };\n      var sizeValue = particle.size.value;\n      var nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n      if (nextBounds.left > canvasSize.width - particle.offset.x) {\n        particle.position.x = newPos.left;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      } else if (nextBounds.right < -particle.offset.x) {\n        particle.position.x = newPos.right;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      }\n\n      if (nextBounds.top > canvasSize.height - particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.top;\n      } else if (nextBounds.bottom < -particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.bottom;\n      }\n    }\n  }, {\n    key: \"updateOutMode\",\n    value: function updateOutMode(delta) {\n      var container = this.container;\n      var particle = this.particle;\n\n      switch (particle.particlesOptions.move.outMode) {\n        case Enums_1.OutMode.bounce:\n        case Enums_1.OutMode.bounceVertical:\n        case Enums_1.OutMode.bounceHorizontal:\n          this.updateBounce(delta);\n          break;\n\n        case Enums_1.OutMode.destroy:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n            particle.destroy();\n            container.particles.remove(particle);\n            return;\n          }\n\n          break;\n\n        case Enums_1.OutMode.out:\n          if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n            this.fixOutOfCanvasPosition();\n          }\n\n      }\n    }\n  }, {\n    key: \"updateBounce\",\n    value: function updateBounce(delta) {\n      var container = this.container;\n      var particle = this.particle;\n      var handled = false;\n\n      var _iterator = _createForOfIteratorHelper(container.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              plugin = _step$value[1];\n\n          if (plugin.particleBounce !== undefined) {\n            handled = plugin.particleBounce(particle, delta);\n          }\n\n          if (handled) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (handled) {\n        return;\n      }\n\n      var outMode = particle.particlesOptions.move.outMode,\n          pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.size.value,\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n        var velocity = particle.velocity.horizontal;\n\n        if (bounds.right >= canvasSize.width && velocity > 0 || bounds.left <= 0 && velocity < 0) {\n          particle.velocity.horizontal *= -1;\n        }\n\n        var minPos = offset.x + size;\n\n        if (bounds.right >= canvasSize.width) {\n          particle.position.x = canvasSize.width - minPos;\n        } else if (bounds.left <= 0) {\n          particle.position.x = minPos;\n        }\n      }\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n        var _velocity = particle.velocity.vertical;\n\n        if (bounds.bottom >= container.canvas.size.height && _velocity > 0 || bounds.top <= 0 && _velocity < 0) {\n          particle.velocity.vertical *= -1;\n        }\n\n        var _minPos = offset.y + size;\n\n        if (bounds.bottom >= canvasSize.height) {\n          particle.position.y = canvasSize.height - _minPos;\n        } else if (bounds.top <= 0) {\n          particle.position.y = _minPos;\n        }\n      }\n    }\n  }]);\n\n  return Updater;\n}();\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/home/majidev/Documentos/dev/portfolio/portfolio-emajidev/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","container","particle","delta","destroyed","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutMode","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","velocity","factor","minimumValue","_a","sizeOpt","size","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","rotateDirection","RotateDirection","clockwise","angle","counterClockwise","color","undefined","h","colorVelocity","stroke","strokeColor","wrap","move","warp","canvasSize","canvas","newPos","bottom","height","offset","y","left","x","right","width","top","nextBounds","Utils","calculateBounds","position","random","outMode","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","isPointInside","particles","remove","out","fixOutOfCanvasPosition","handled","plugins","plugin","particleBounce","pos","getPosition","bounds","minPos"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const particle = this.particle;\n        const rotate = particle.particlesOptions.rotate;\n        const rotateAnimation = rotate.animation;\n        const speed = (rotateAnimation.speed / 360) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotate.path) {\n            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n        }\n        else {\n            if (rotateAnimation.enable) {\n                switch (particle.rotateDirection) {\n                    case Enums_1.RotateDirection.clockwise:\n                        particle.angle += speed;\n                        if (particle.angle > max) {\n                            particle.angle -= max;\n                        }\n                        break;\n                    case Enums_1.RotateDirection.counterClockwise:\n                    default:\n                        particle.angle -= speed;\n                        if (particle.angle < 0) {\n                            particle.angle += max;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    updateColor(delta) {\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.strokeColor.h > 360) {\n                particle.strokeColor.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.size.value - particle.offset.y,\n            left: -particle.size.value - particle.offset.x,\n            right: canvasSize.width + particle.size.value + particle.offset.x,\n            top: -particle.size.value - particle.offset.y,\n        };\n        const sizeValue = particle.size.value;\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateOutMode(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        switch (particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    particle.destroy();\n                    container.particles.remove(particle);\n                    return;\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    this.fixOutOfCanvasPosition();\n                }\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const outMode = particle.particlesOptions.move.outMode, pos = particle.getPosition(), offset = particle.offset, size = particle.size.value, bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n            const velocity = particle.velocity.horizontal;\n            if ((bounds.right >= canvasSize.width && velocity > 0) || (bounds.left <= 0 && velocity < 0)) {\n                particle.velocity.horizontal *= -1;\n            }\n            const minPos = offset.x + size;\n            if (bounds.right >= canvasSize.width) {\n                particle.position.x = canvasSize.width - minPos;\n            }\n            else if (bounds.left <= 0) {\n                particle.position.x = minPos;\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n            const velocity = particle.velocity.vertical;\n            if ((bounds.bottom >= container.canvas.size.height && velocity > 0) || (bounds.top <= 0 && velocity < 0)) {\n                particle.velocity.vertical *= -1;\n            }\n            const minPos = offset.y + size;\n            if (bounds.bottom >= canvasSize.height) {\n                particle.position.y = canvasSize.height - minPos;\n            }\n            else if (bounds.top <= 0) {\n                particle.position.y = minPos;\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}